// Name: Rafaela Lomboy
// Last Four Digits of ID: 1064

package org.csc133.a1;

import static com.codename1.ui.CN.*;

import com.codename1.charts.util.ColorUtil;
import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.Button;
import com.codename1.ui.Dialog;
import com.codename1.ui.Font;
import com.codename1.ui.Graphics;
import com.codename1.ui.geom.Point;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.util.UITimer;

import javax.swing.border.Border;
import java.awt.*;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Random;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename
 * One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain extends Lifecycle {
    @Override
    public void runApp() {
        Game game = new Game();
        game.show();
    }
}

// ----------------------------------------------------------------------------
// Initializes game world. Source of graphics context each object uses to draw.
//
class Game extends Form implements Runnable{
    final private GameWorld gw;

    final static int DISP_W = Display.getInstance().getDisplayWidth();
    final static int DISP_H = Display.getInstance().getDisplayHeight();

    public static int getSmallDim(){ return Math.min(DISP_W, DISP_H); }
    public static int getLargeDim(){ return Math.max(DISP_W, DISP_H); }

    public Game(){
        gw = new GameWorld();

        // key listeners to control user input
        //
        addKeyListener(-93, (evt) -> gw.processKeyPress(-93));
        addKeyListener(-94, (evt) -> gw.processKeyPress(-94));
        addKeyListener(-91, (evt) -> gw.processKeyPress(-91));
        addKeyListener(-92, (evt) -> gw.processKeyPress(-92));
        addKeyListener('f', (evt) -> gw.processKeyPress('f'));
        addKeyListener('d', (evt) -> gw.processKeyPress('d'));
        addKeyListener('Q', (evt) -> gw.quit());

        UITimer timer = new UITimer(this);
        timer.schedule(20, true, this);

        this.getAllStyles().setBgColor(ColorUtil.BLACK);
        this.show();
    }

    @Override
    public void paint(Graphics g){
        super.paint(g);
        gw.draw(g);
    }

    @Override
    public void run() {
        gw.tick();
        repaint();
    }
}

// ----------------------------------------------------------------------------
// Holds state of game, determines win/lose conditions and links Game objects.
//
class GameWorld{
    private River river;
    private Helipad helipad;
    private Helicopter helicopter;
    private ArrayList<Fire> fires;
    private int displayWidth, displayHeight;
    final int INITIAL_FUEL;
    private enum Result {LOST, WON};

    public GameWorld(){
        displayWidth = Game.DISP_W;
        displayHeight = Game.DISP_H;
        INITIAL_FUEL = 25000;

        init();
    }

    void init(){
        river = new River();
        helipad = new Helipad();
        helicopter = new Helicopter(helipad.getCenter(), INITIAL_FUEL);
        fires = new ArrayList<>();
        addFiresToRandomLocations();
    }

    // update state of game
    //
    void tick(){
        helicopter.move();
        helicopter.reduceFuel();
        randomlyGrowFires();
        endGame();
    }

    void processKeyPress(int keyCode){
        switch(keyCode){
            case -93:
                helicopter.turnLeft();
                break;
            case -94:
                helicopter.turnRight();
                break;
            case -91:
                helicopter.increaseSpeed();
                break;
            case -92:
                helicopter.decreaseSpeed();
                break;
            case 'f':
                fightFiresIfHeliIsNear();
                break;
            case 'd':
                if(helicopter.isAboveRiver(river))  // move to drink method?
                    helicopter.drink();
                break;
        }
    }

    private void endGame() {
        if(helicopter.fuel() <= 0)
            gameOver(Result.LOST);
        else if(helicopter.hasLandedOnHelipad(helipad) && allFiresAreOut())
            gameOver(Result.WON);
    }

    private void randomlyGrowFires() {
        if(fires.size()>0 && getRand(0, 5) == 0) {
            int randomFire = getRand(0, fires.size());
            if(fires.get(randomFire).size() > 0)
                fires.get(randomFire).grow();
        }
    }

    private void fightFiresIfHeliIsNear() {
        ArrayList<Fire> deadFires = new ArrayList<>();
        for(Fire fire : fires){
            if(helicopter.isWithinRangeOfFire(fire))
                helicopter.fight(fire);

            if(fire.size() == 0)
                deadFires.add(fire);
        }
        helicopter.dumpWater();
        fires.removeAll(deadFires);
    }

    void gameOver(Result result){
        boolean replayGame = Dialog.show("Game Over", replayPrompt(result),
                            "Heck Yeah!", "Some Other Time");

        if(replayGame)
            new Game();
        else
            quit();
    }

    private String replayPrompt(Result result) {
        String dialogMsg = "";

        if(result == Result.LOST){
            dialogMsg = "You ran out of fuel :(\nPlay Again?";
        }
        else if(result == Result.WON){
            dialogMsg = "You won!" + "\nScore: " + helicopter.fuel()
                    + "\nPlay Again?";
        }

        return dialogMsg;
    }

    void quit(){
        Display.getInstance().exitApplication();
    }

    boolean allFiresAreOut(){
        return fires.size() == 0;
    }

    private void addFiresToRandomLocations(){
        addFireAboveRightRiver();
        addFireAboveLeftRiver();
        addFireBelowCenterRiver();
    }

    private void addFireAboveRightRiver(){
        int fSize = getRand(10, 500);
        Point fLocation = new Point(getRand(displayWidth/2,
                                            displayWidth-fSize),
                                    getRand(0, river.getLocation().getY()));
        fires.add(new Fire(fSize, fLocation));
    }

    private void addFireBelowCenterRiver() {
        int fSize = getRand(10, 500);
        int riverLowerBound = river.getLocation().getY() + river.height();
        int aboveHelipad = helipad.getLocation().getY() - fSize;
        Point fLocation = new Point(getRand(displayWidth/2 - fSize,
                                            displayWidth/2 + fSize),
                                    getRand(riverLowerBound, aboveHelipad));
        fires.add(new Fire(fSize, fLocation));
    }

    private void addFireAboveLeftRiver() {
        int fSize = getRand(10, 500);
        Point fLocation = new Point(getRand(displayWidth/4,
                displayWidth/2-fSize),
                getRand(0, river.getLocation().getY()));
        fires.add(new Fire(fSize, fLocation));
    }

    // generates random number, lower is inclusive, upper is exclusive
    //
    int getRand(int lower, int upper){
        Random rand = new Random();
        return rand.nextInt(upper-lower) + lower;
    }

    void draw(Graphics g){
        g.clearRect(0, 0, displayWidth, displayHeight);
        river.draw(g);
        helipad.draw(g);
        for(Fire fire : fires)
            fire.draw(g);
        helicopter.draw(g);
    }
}

// ----------------------------------------------------------------------------
//
class River{
    final private Point location;
    final private int width;
    final private int height;

    public River(){
        width = Game.DISP_W;
        height = Game.DISP_H/10;
        location = new Point(0, Game.DISP_H/5);
    }

    Point getLocation(){
        return location;
    }

    int width(){
        return width;
    }

    int height(){
        return height;
    }

    void draw(Graphics g){
        g.setColor(ColorUtil.BLUE);
        g.drawRect(location.getX(), location.getY(), width, height);
    }
}

// ----------------------------------------------------------------------------
//
class Fire{
    private Point location;
    final private Point center;
    private int size;

    public Fire(int size, Point location){
        this.size = size;
        this.location = location;
        this.center = new Point(location.getX() + size/2,
                                location.getY() + size/2);
    }

    // increase size without changing the center of the fire
    //
    void grow(){
        Random rand = new Random();
        int increase = rand.nextInt(2);

        size += increase;
        location = new Point(center.getX() - size/2,center.getY() - size/2);
    }

    void shrink(int reduce){
        size -= reduce;
        if(size < 0) size = 0;

        location = new Point(center.getX() - size/2,center.getY() - size/2);
    }

    Point getLocation() {
        return location;
    }

    Point getCenter() {
        return center;
    }

    int size(){
        return size;
    }

    void draw(Graphics g){
        g.setFont(Font.createSystemFont(FACE_SYSTEM, STYLE_BOLD, SIZE_MEDIUM));
        g.setColor(ColorUtil.MAGENTA);

        if(size > 0) {
            g.fillArc(location.getX(), location.getY(), size, size,
                    0, 360);
            g.drawString(Integer.toString(size),
                    location.getX() + size, location.getY() + size);
        }
    }
}

// ----------------------------------------------------------------------------
//
class Helipad{
    final private Point location;
    final private Point center;
    final private int sSize;
    final private int cSize;
    final private int cOffset;
    private int displayWidth, displayHeight;

    public Helipad(){
        displayWidth = Game.DISP_W;
        displayHeight = Game.DISP_H;
        sSize = displayHeight/8;
        cOffset = 40;
        cSize = sSize-cOffset;

        // located at half the screen width and its width above the bottom
        //
        location = new Point(displayWidth/2 - sSize/2,
                             displayHeight - (int)(sSize*1.5));
        center = new Point(location.getX() + sSize/2,
                           location.getY() + sSize/2);
    }

    Point getCenter(){
        return center;
    }

    Point getLocation(){
        return location;
    }

    int circleDiameter() {
        return cSize;
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.GRAY);
        g.drawRect(location.getX(), location.getY(), sSize, sSize, 5);
        g.drawArc(location.getX() + cOffset/2,location.getY() + cOffset/2,
                    cSize, cSize, 0, 360);
    }
}

// ----------------------------------------------------------------------------
//
class Helicopter{
    private Point location, center;
    final private int size;
    final private int displayWidth, displayHeight;
    private int fuel, water;
    private int speed;
    private int heading;
    private final int headingRadius;
    final private int MAX_SPEED = 10;
    final private int MAX_WATER = 1000;
    private double angle;

    public Helicopter(Point helipadCenter, int initFuel){
        displayWidth = Game.DISP_W;
        displayHeight = Game.DISP_H;
        fuel = initFuel;
        water = 0;
        speed = 0;
        heading = 0;
        angle = Math.toRadians(heading);
        size = displayHeight/40;
        headingRadius = size*2;

        center = new Point(helipadCenter.getX(), helipadCenter.getY()+size);
        location = new Point(center.getX()-size/2,center.getY()-size/2);
    }

    void turnRight(){
        if(heading < 0 || heading > 360)
            heading = 360;
        heading -= 15;
    }

    void turnLeft(){
        if(heading < 0 || heading > 360)
            heading = 0;
        heading += 15;
    }

    void move(){
        center = new Point(center.getX() + (int)(speed*Math.cos(angle)),
                           center.getY() - (int)(speed*Math.sin(angle)));
        location = new Point(center.getX()-size/2,center.getY()-size/2);
    }

    void increaseSpeed(){
        if(speed != MAX_SPEED) speed++;
    }

    void decreaseSpeed(){
        if(speed != 0) speed--;
    }

    void drink(){
        if(speed < 3 && water < MAX_WATER)
            water += 100;
    }

    void fight(Fire fire){
        fire.shrink(water/4);
    }

    void dumpWater(){
        water = 0;
    }

    void reduceFuel(){
        fuel -= speed*speed + 5;
        if(fuel < 0) fuel = 0;
    }

    int fuel() {
        return fuel;
    }

    boolean isAboveRiver(River river){
        int rX1 = river.getLocation().getX();
        int rX2 = river.getLocation().getX()  + river.width();
        int rY1 = river.getLocation().getY();
        int rY2 = river.getLocation().getY()  + river.height();

        return hasCollided(rX1, rX2, rY1, rY2);
    }

    boolean isWithinRangeOfFire(Fire fire) {
        // fire bounding box values
        //
        int fX1 = fire.getLocation().getX()-10;
        int fX2 = fire.getLocation().getX()+fire.size()+10;
        int fY1 = fire.getLocation().getY()-10;
        int fY2 = fire.getLocation().getY()+fire.size()+10;

        // helicopter is within bounding box of fire
        //
        if(hasCollided(fX1, fX2, fY1, fY2)){
            // small fire sizes only require heli to be within range of fire
            //
            if(fire.size() < 100)
                return true;
            else
                return isWithinCircle(fire.getCenter(), fire.size());
        }

        return false;
    }

    boolean hasLandedOnHelipad(Helipad helipad){
        return isWithinCircle(helipad.getCenter(), helipad.circleDiameter());
    }

    // checks for collision with other object (passes in bounding box values)
    // x1: left bound, x2: right bound, y1: upper bound, y2 lower bound
    //
    private boolean hasCollided(int x1, int x2, int y1, int y2){
        // set helicopter bounding box values
        //
        int hX1 = location.getX();
        int hX2 = location.getX() + size;
        int hY1 = location.getY();
        int hY2 = location.getY() + size;

        // check bounding box conditions (these are true if NO collision)
        //
        return !(hX1 > x2) && !(hX2 < x1) && !(hY1 > y2) && !(hY2 < y1);
    }

    private boolean isWithinCircle(Point cCenter, int diameter){
        int x = center.getX() - cCenter.getX();
        int y = center.getY() - cCenter.getY();

        // applies distance formula to see if helicopter is near a fire:
        // d = sqrt(a^2 + b^2)
        //
        return Math.sqrt(x*x + y*y) <= (double)(diameter/2);
    }

    void draw(Graphics g){
        angle = Math.toRadians(heading) + Math.PI/2;

        g.setColor(ColorUtil.YELLOW);
        g.setFont(Font.createSystemFont(FACE_SYSTEM, STYLE_BOLD, SIZE_MEDIUM));

        // draw helicopter body and show stats
        //
        g.fillArc(location.getX(), location.getY(), size, size,
                0, 360);
        g.drawString("F:  " + fuel, location.getX() - size/2,
                location.getY() + size*2);
        g.drawString("W: " + water, location.getX() - size/2,
                location.getY() + size*3);

        // use polar to coordinate conversion for heading line position
        //
        int heX = center.getX() + (int)(headingRadius * Math.cos(angle));
        int heY = center.getY() - (int)(headingRadius * Math.sin(angle));

        g.drawLine(center.getX(), center.getY(), heX, heY);
    }
}